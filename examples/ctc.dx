def logsoftmax (x: n=>Float) : n=>Float =
  for i. x.i - x.(0@_)

def ctc (time : Type) ?-> (vocab : Type) ?-> (position : Type) ?->
        (dict: Eq vocab) ?=> (dict2: Eq position) ?=> (dict3: Eq time) ?=> (blank: vocab)
        (logits: time=>vocab=>Float) (labels: position=>vocab) : Float =
  normalized_logits = for t:time. logsoftmax logits.t
  normalized_logits.(1@_).(labels.(0@_))

'### Demo

def randIdxNoZero (n:Type) -> (k:Key) : n =
  unif = rand k
  fromOrdinal n $ (1 + (FToI (floor ( unif * IToF ((size n) - 1)))))

vocab = Fin 6
blank = 0@vocab

-- Create random logits
time = Fin 4
logits = for i:time j:vocab. (randn $ ixkey2 (newKey 0) i j)

'### Test

-- Check that the sum of p(labels|logits) sums to 1.0 over all possible labels.
-- They don't yet sum to one, however I'm not 100% sure about the
-- semantics of the marginal likelihood being computed, and whether
-- e.g. the summed-over labels should include blanks.


sums = for i:vocab. ctc blank logits [i]
sums

--sum sums

blank
logits

%passes
sum $ for i:vocab. ctc blank logits [i]

--%passes
--:p
  --tmp = for i:vocab. ctc blank logits [i]
  --withState 0.0 \s.
    --for i:vocab.
      --s := get s + tmp.i
      --()
